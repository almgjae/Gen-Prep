<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>생기부 면접 대비</title>
<style>
  :root{
    --bg:#0f172a; --bg2:#0b1022; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb;
    --accent:#4C08A3; --accent2:#7c3aed; --danger:#ef4444; --ok:#10b981; --border:#1f2937;
    --chip:#1e293b; --shadow: rgba(2,6,23,.3);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(135deg, var(--bg), var(--bg2)); color:var(--text);
    font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Arial,"Apple Color Emoji","Segoe UI Emoji";
    letter-spacing:.2px;
  }
  a{color:inherit; text-decoration:none}
  .app{display:grid; grid-template-columns: 280px 1fr; height:100%; transition: grid-template-columns .2s ease-in-out;}
  .app.collapsed { grid-template-columns: 0px 1fr; }
  .app.collapsed .sidebar { transform: translateX(-100%); transition: transform .2s ease-in-out; }
  
  /* ADDED: Style for full-screen practice mode */
  .app.practice-mode {
    grid-template-columns: 1fr;
  }
  .app.practice-mode .main {
    width: 100%;
    max-width: none;
  }
  /* END ADDED */

  .sidebar{
    border-right:1px solid var(--border); background:rgba(15,23,42,.08);
    backdrop-filter: blur(6px); padding:16px 12px; display:flex; flex-direction:column; gap:12px;
    height: 100%;
    overflow-y: auto;
  }
  .brand{display:flex; align-items:center; gap:10px; font-weight:700}
  .brand svg{width:20px;height:20px}
  .pill{font-size:12px; padding:2px 8px; border:1px solid var(--border); border-radius:999px; color:var(--muted)}
  .nav{display:flex; flex-direction:column; gap:6px; margin-top:4px}
  .nav a{padding:10px 12px; border-radius:10px; border:1px solid transparent}
  .nav a.active{background:rgba(124,58,237,.15); border-color:#3b246a}
  .muted{color:var(--muted)}
  .divider{height:1px; background:var(--border); margin:8px 0}
  .subjects{display:flex; flex-direction:column; gap:6px; overflow:auto; padding-right:4px}
  .chip{display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:12px; background:var(--chip); border:1px solid var(--border); cursor:pointer; white-space:nowrap}
  .chip.active {
    background-color: rgba(76, 8, 163, 0.5); /* new */
    border: 1px solid rgba(76, 8, 163, 0.8); /* new */
  }
  .row{display:flex; align-items:center; gap:8px}
  .row-nowrap{display:flex; align-items:center; gap:8px; flex-wrap:nowrap}
  .col{display:flex; flex-direction:column; gap:8px}
  .input, .search, .field, select{
    border:1px solid var(--border); background:var(--bg2); color:var(--text); border-radius:12px; padding:10px 12px; outline:none; width:100%;
  }
  .inline-field{ width:auto !important; min-width:80px; }
  .button{
    border:1px solid var(--border); background:linear-gradient(180deg, #5c11c7, #4c08a3); /* new */
    border-color:#4c08a3; /* new */
    cursor:pointer; user-select:none;
    display:inline-flex; align-items:center; justify-content:center; width:auto; white-space:nowrap; color:var(--text);
  }
  .button:hover{filter:brightness(1.05)}
  .button.small{padding:8px 12px; border-radius:10px}
  .button.ghost{background:transparent; border-color:var(--border); color:var(--text)}
  .button.danger{background:linear-gradient(180deg,#3d0d12,#28090c); border-color:#5f141a; color:#fecaca}
  .topbar{display:flex; gap:8px; align-items:center; padding:12px 16px; border-bottom:1px solid var(--border); background:rgba(2,6,23,.05); backdrop-filter: blur(6px)}
  .topbar .search{max-width:360px}
  .main{display:flex; flex-direction:column; height:100%}
  .content{padding:16px; overflow:auto; height:100%}
  .card{background:rgba(17,24,39,.06); border:1px solid var(--border); border-radius:16px; padding:16px; box-shadow:0 10px 30px var(--shadow)}
  h1{font-size:20px; margin:0 0 6px 0}
  h2{font-size:18px; margin:0 0 6px 0}
  label{color:var(--text)}
  .grid{display:grid; gap:12px}
  .grid-2{grid-template-columns: 1fr 1fr}
  .grid-3{grid-template-columns: repeat(3, 1fr)}
  .grid-4{grid-template-columns: repeat(4, 1fr)}
  .menu-btn{display:none}
  .subject-add-box{ max-width: 140px; }
  
  /* Hide scrollbars */
  ::-webkit-scrollbar {
    width: 0;
    height: 0;
  }
  * {
    scrollbar-width: none;
  }

  @media (max-width: 1000px){
    .app{grid-template-columns:1fr}
    .sidebar{position:fixed; inset:0 0 auto 0; height:65vh; transform:translateY(-110%); transition:transform .2s; z-index:40}
    .sidebar.open{transform:translateY(0)}
    .grid-2 { grid-template-columns: 1fr; }
    .menu-btn{display:block}
    .subjects { display: none; }
    .sidebar > .muted { display: none; }
    
    /* Mobile-specific changes for subject table */
    .table thead th:nth-child(3),
    .table tbody td:nth-child(3) {
      display: none;
    }
  }

  .empty{padding:18px; border:1px dashed var(--border); border-radius:12px; color:var(--muted); background:rgba(2,6,23,.03)}
  details{border:1px solid var(--border); border-radius:12px; padding:12px; background:var(--bg2)}
  summary{cursor:pointer; font-weight:600}
  textarea{
    min-height:120px;
    resize:none;
    overflow: hidden;
  }
  .srb-box{white-space:pre-wrap; background:var(--bg2); border:1px solid var(--border); border-radius:12px; padding:12px; min-height:220px; overflow-wrap: break-word; overflow-y: auto;}
  .toolbar{display:flex; gap:8px; justify-content:flex-end; margin-top:10px; flex-wrap:wrap}
  .tag{font-size:12px; padding:2px 8px; border:1px solid var(--border); border-radius:999px}
  .table{width:100%; border-collapse: collapse}
  .table th,.table td{padding:8px 10px; border-bottom:1px solid var(--border); text-align:left; vertical-align:top}
  .toast{position:fixed; right:18px; bottom:18px; padding:12px 14px; border-radius:12px; background:rgba(16,185,129,.15); color:#d1fae5; border:1px solid rgba(16,185,129,.35); backdrop-filter: blur(6px); display:none; z-index:50}
  .toast.error{background:rgba(239,68,68,.1); color:#fecaca; border-color:rgba(239,68,68,.35)}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; background:var(--bg2); border:1px solid var(--border); padding:2px 6px; border-radius:6px; color:var(--text)}
  .timer{font-variant-numeric: tabular-nums; font-weight:700}
  .bar{height:10px; border-radius:999px; border:1px solid var(--border); background:rgba(2,6,23,.25); overflow:hidden}
  .bar > span{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent2),var(--accent)); transition: width .2s linear}
  .timer-danger{color:#fecaca}
  .hscroll{display:flex; gap:8px; overflow:auto; padding-bottom:4px}
  ::placeholder{color:var(--muted)}

  /* Practice mode specific styles */
  .practice-main{
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    height:100%; padding:16px;
  }
  .practice-card{
    background:rgba(17,24,39,.06); border:1px solid var(--border);
    border-radius:16px; padding:16px; max-width: 800px; width:100%;
  }

</style>

<!-- Adsafe Animations & UX Enhancements -->
<!-- FX: Robust Text Animations -->

<!-- FX v3: Subtle Global Animations (No Flicker) -->
<style id="fx-anim-v3">
:root{
  --fx-ease: cubic-bezier(0.22, 1, 0.36, 1);
  --fx-dur: .50s;
  --fx-stagger: 70ms;
  --fx-radius: 16px;
}
/* Title styling without infinite animation to avoid flicker */
.card h1, .card h2{ margin-top:.25rem; margin-bottom:.5rem; }

/* View fade-in on route swap */
.fx-view-in{ animation: fxViewIn .38s var(--fx-ease) both; }
@keyframes fxViewIn{ from{opacity:0} to{opacity:1} }

/* Element reveal (once) */
.fx-reveal{ opacity:0; transform: translateY(8px) scale(.995); will-change: transform, opacity; }
.fx-reveal.is-in{ opacity:1; transform: translateY(0) scale(1); transition: transform var(--fx-dur) var(--fx-ease), opacity var(--fx-dur) var(--fx-ease); transition-delay: var(--fx-delay, 0s); }

/* Micro-interactions */
.card{ border-radius: var(--fx-radius); transition: transform .12s var(--fx-ease), box-shadow .18s var(--fx-ease); backface-visibility: hidden; }
.card:hover{ transform: translateY(-2px); box-shadow: 0 10px 24px rgba(0,0,0,.08); }
.button, button{ transition: transform .08s var(--fx-ease), box-shadow .12s var(--fx-ease); }
.button:hover, button:hover{ transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,.16); }
.field, input, textarea, select{ transition: box-shadow .18s var(--fx-ease), border-color .18s var(--fx-ease); }
.field:focus, input:focus, textarea:focus, select:focus{ box-shadow: 0 0 0 3px rgba(99,102,241,.25); outline: none; }

/* Stagger helpers */
.fx-stagger > *{ --fx-delay: 0ms; }
.fx-stagger > *:nth-child(1){ --fx-delay: calc(var(--fx-stagger) * 0); }
.fx-stagger > *:nth-child(2){ --fx-delay: calc(var(--fx-stagger) * 1); }
.fx-stagger > *:nth-child(3){ --fx-delay: calc(var(--fx-stagger) * 2); }
.fx-stagger > *:nth-child(4){ --fx-delay: calc(var(--fx-stagger) * 3); }
.fx-stagger > *:nth-child(5){ --fx-delay: calc(var(--fx-stagger) * 4); }
.fx-stagger > *:nth-child(6){ --fx-delay: calc(var(--fx-stagger) * 5); }
.fx-stagger > *:nth-child(7){ --fx-delay: calc(var(--fx-stagger) * 6); }
.fx-stagger > *:nth-child(8){ --fx-delay: calc(var(--fx-stagger) * 7); }
.fx-stagger > *:nth-child(9){ --fx-delay: calc(var(--fx-stagger) * 8); }
.fx-stagger > *:nth-child(10){ --fx-delay: calc(var(--fx-stagger) * 9); }

/* Accessibility: reduce motion */
@media (prefers-reduced-motion: reduce){
  .fx-view-in, .fx-reveal, .fx-reveal.is-in{ animation: none !important; transition: none !important; opacity: 1 !important; transform: none !important; }
}

/* Never animate ads to avoid accidental clicks */
ins.adsbygoogle, .adsbygoogle{ animation: none !important; transition: none !important; }
</style>


<!-- Intro styles -->
<style id="intro-style">
#intro-overlay{ background: radial-gradient(1200px 800px at 20% 10%, rgba(99,102,241,.10), transparent 60%),
                radial-gradient(1000px 700px at 80% 90%, rgba(34,197,94,.10), transparent 60%),
                #0b1220; }
.intro-bg{ position:absolute; inset:0; overflow:hidden; pointer-events:none; }
.blob{ position:absolute; width:38vmax; height:38vmax; filter: blur(48px); opacity:.18; }
.blob.b1{ background: #6366f1; top:-10vmax; left:-8vmax; animation: float1 18s ease-in-out infinite; }
.blob.b2{ background: #22c55e; bottom:-12vmax; right:-10vmax; animation: float2 22s ease-in-out infinite; }
@keyframes float1{ 0%,100%{ transform: translateY(0) translateX(0) scale(1);} 50%{ transform: translateY(3vmax) translateX(1vmax) scale(1.05);} }
@keyframes float2{ 0%,100%{ transform: translateY(0) translateX(0) scale(1);} 50%{ transform: translateY(-2vmax) translateX(-1vmax) scale(1.06);} }
.grid-dots{ position:absolute; inset:0; background-image: radial-gradient(rgba(255,255,255,.04) 1px, transparent 1px);
            background-size: 22px 22px; mask-image: radial-gradient(circle at 60% 50%, black, transparent 65%); }

.intro-wrap{ position:relative; min-height:100%; display:grid; place-items:center; padding: clamp(16px,3vw,48px); }
.intro-card{ width:min(840px, 92vw); background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08);
             border-radius: 18px; box-shadow: 0 20px 60px rgba(0,0,0,.35); padding: clamp(20px, 3vw, 44px);
             backdrop-filter: blur(6px); animation: introPop .48s cubic-bezier(0.22,1,0.36,1) both; }
@keyframes introPop{ from{ opacity:0; transform: translateY(14px) scale(.985);} to{ opacity:1; transform: translateY(0) scale(1);} }

.intro-title{ font-size: clamp(28px, 5vw, 44px); line-height:1.15; margin: 0 0 10px 0; 
  background: linear-gradient(90deg,#e5e7eb,#c7d2fe,#e5e7eb);
  -webkit-background-clip:text; background-clip:text; color: transparent; -webkit-text-fill-color: transparent;
}
.intro-sub{ color: #cbd5e1; font-size: clamp(14px, 2.2vw, 18px); margin: 6px 0 18px; }
.intro-feats{ color: #e2e8f0; display:grid; gap:8px; margin: 10px 0 22px; padding-left: 18px; }
.intro-feats li{ list-style: '✓  '; opacity:.92; }
.intro-cta{ display:flex; align-items:center; margin-top:8px; }
.button.large{ font-size: 16px; padding: 12px 18px; border-radius: 12px; }

@media (prefers-reduced-motion: reduce){
  .blob{ animation: none; }
  .intro-card{ animation: none; }
}
</style>



<style id="fx-anim-route-guard">
/* Practice route: keep things calm but not dead */
.fx-practice-lite .fx-view-in{ animation: none !important; } /* no global view fade on practice */
#media-view, #practiceArea video, #practiceArea canvas{ animation: none !important; transition: none !important; }
.no-anim, .no-ads{ animation: none !important; transition: none !important; }
</style>
    

<style>
/* --- AdSafe patch: begin --- */
ins.adsbygoogle, .adsbygoogle{
  display:block !important;
  margin:16px auto !important;
  max-width:100% !important;
}
.no-ads ins.adsbygoogle,
.practice-mode ins.adsbygoogle{
  display:none !important;
  visibility:hidden !important;
}
/* --- AdSafe patch: end --- */
</style></head>
<body>
<!-- Intro / Landing Overlay (no ads) -->
<div id="intro-overlay" class="no-ads" data-adbreak="off" style="position:fixed; inset:0; z-index:9999; display:none;">
  <div class="intro-bg">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="grid-dots"></div>
  </div>
  <div class="intro-wrap">
    <div class="intro-card">
      <h1 class="intro-title">생기부 면접 대비 도우미</h1>
      <ul class="intro-feats">
        <li>실전 연습 모드 (타이머·카메라·녹음)</li>
        <li>생기부 분석으로 <b>핵심 흐름/키워드/문장</b> 자동 정리</li>
        <li>교과별 예상 질문과 <b>즐겨찾기</b> 관리</li>
      </ul>
      <div class="intro-cta">
        <button id="enterApp" class="button large">입장하기</button>
        <a id="skipIntro" class="muted" style="margin-left:12px; cursor:pointer;">다음부터 보지 않기</a>
      </div>
    </div>
  </div>
</div>

<div class="app" id="app">
  <aside class="sidebar" id="sidebar">
    <div class="brand">
      <svg viewBox="0 0 24 24" fill="none"><path d="M4 7a3 3 0 0 1 3-3h5l2 2h2a4 4 0 0 1 4 4v8a3 3 0 0 1-3-3H7a3 3 0 0 1-3-3V7z" stroke="url(#g)" stroke-width="1.5"/><defs><linearGradient id="g" x1="0" x2="1" y1="0" y2="1"><stop stop-color="#22d3ee"/><stop offset=".9" stop-color="#7c3aed"/></linearGradient></defs></svg>
      생기부 면접 대비 <span class="pill">
    </div>
    <nav class="nav" id="mainNav">
      <a href="#/dashboard" data-route>🏠 홈</a>
      <a href="#/subjects" data-route>📚 교과 목록</a>
      <a href="#/practice" data-route>🎤 연습 모드</a>
      <a href="#/analyze" data-route>✏️ 생기부 분석</a>
      <a href="#/questions" data-route>❓ 예상 질문</a>
      <a href="#/all-questions" data-route>❔ 전체 질문</a>
      <a href="#/settings" data-route>⚙️ 설정</a>
    </nav>
    <div class="divider"></div>
    <div class="row">
      <input id="newSubjectInput" class="input subject-add-box" placeholder="새 교과명" />
      <button class="button small" id="addSubjectBtn">➕ 추가</button>
    </div>
    <div class="divider"></div>
    <div class="muted">교과 바로가기</div>
    <div class="subjects" id="subjectQuickList"></div>
    <div class="divider"></div>
  </aside>

  <main class="main">
    <div class="topbar">
      <button class="button small menu-btn" id="toggleMenu">☰ 메뉴</button>
      <input id="searchInput" class="search" placeholder="교과 검색: 이름 일부 입력 후 Enter" />
      <button class="button small" id="searchBtn">🔎 검색</button>
      <span class="muted" id="searchHint"></span>
    </div>
    <div class="content" id="view"></div>
  </main>
</div>

<div class="toast" id="toast"></div>

<script>
(function(){
  const LS_KEY = "interviewPrep.SPA.v6.darkOnly.hintInline";
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  const app = {
    state: {
      subjects: [],
      sessions: [],
      prefs: {},
      selectedSubjectId: null
    },
    init(){
      const saved = localStorage.getItem(LS_KEY);
      if(saved){ try{ this.state = JSON.parse(saved) }catch(e){} }
      if(!this.state.subjects || this.state.subjects.length===0){
        this.state.subjects = [];
        this.state.selectedSubjectId = null;
      } else {
        // migrate: ensure each question has hint
        this.state.subjects.forEach(s=> (s.questions||[]).forEach(q=>{ if(typeof q.hint!=="string") q.hint=""; }));
      }
      if(!this.state.sessions) this.state.sessions = [];
      if(!this.state.prefs) this.state.prefs = {};

      this.cacheEls();
      this.bind();
      this.renderSidebar();
      this.route();
    },
    cacheEls(){
      this.sidebar = $("#sidebar");
      this.subjectQuickList = $("#subjectQuickList");
      this.newSubjectInput = $("#newSubjectInput");
      this.addSubjectBtn = $("#addSubjectBtn");
      this.searchInput = $("#searchInput");
      this.searchBtn = $("#searchBtn");
      this.searchHint = $("#searchHint");
      this.view = $("#view");
      this.toggleMenu = $("#toggleMenu");
      this.app = $("#app");
      this.mainNav = $("#mainNav");
    },
    bind(){
      window.addEventListener("hashchange", ()=> this.route());
      this.addSubjectBtn.addEventListener("click", ()=> this.addSubject());
      this.newSubjectInput.addEventListener("keydown", e=>{ if(e.key==="Enter") this.addSubject(); });
      this.searchBtn.addEventListener("click", ()=> this.searchGo());
      this.searchInput.addEventListener("keydown", e=>{ if(e.key==="Enter") this.searchGo(); });

      document.addEventListener("keydown", (e)=>{
      // 단축키 코드 삭제됨
      });
      this.toggleMenu.addEventListener("click", ()=> {
        if(window.innerWidth <= 1000){
          this.sidebar.classList.toggle("open");
        } else {
          this.app.classList.toggle("collapsed");
        }
      });
      this.mainNav.addEventListener("click", (e) => {
          if (e.target.tagName === 'A' && window.innerWidth <= 1000) {
              this.sidebar.classList.remove("open");
          }
      });
    },
    save(){ localStorage.setItem(LS_KEY, JSON.stringify(this.state)); },
    toast(msg, err=false){
      const t = $("#toast"); t.textContent = msg; t.classList.toggle("error", !!err);
      t.style.display="block"; setTimeout(()=> t.style.display="none", 1600);
    },
    uidForName(name){ const s=this.state.subjects.find(x=>x.name.toLowerCase()===name.toLowerCase()); return s?.id||null; },
    addSubject(nameFromArg){
      const name = (nameFromArg ?? this.newSubjectInput.value).trim();
      if(!name){ this.toast("교과명을 입력하세요", true); return; }
      if(this.uidForName(name)){ this.toast("이미 있는 교과입니다", true); return; }
      const sub = { id: uid(), name, srb:"", questions:[], createdAt: now(), updatedAt: now() };
      this.state.subjects.push(sub);
      this.state.selectedSubjectId = sub.id;
      this.newSubjectInput.value="";
      this.save(); this.renderSidebar();
      location.hash = "#/subjects/" + sub.id;
    },
    deleteSubject(id){
      const idx = this.state.subjects.findIndex(s=>s.id===id);
      if(idx<0) return;
      if(!confirm("정말 삭제할까요? 이 교과의 질문도 함께 삭제됩니다.")) return;
      this.state.subjects.splice(idx,1);
      if(this.state.selectedSubjectId===id) this.state.selectedSubjectId = this.state.subjects[0]?.id || null;
      this.save(); 
      this.renderSidebar(); 
      this.viewSubjects();
      location.hash = "#/subjects";
      this.toast("삭제되었습니다");
    },
    renameSubject(id){
      const s = this.state.subjects.find(x=>x.id===id); if(!s) return;
      const name = prompt("새 교과명", s.name); if(!name) return;
      if(this.uidForName(name) && this.uidForName(name)!==id){ this.toast("동일 이름이 이미 있습니다", true); return; }
      s.name = name.trim(); s.updatedAt = now(); this.save(); this.renderSidebar(); this.route(); this.toast("이름 변경됨");
    },
    searchGo(){
      const q = this.searchInput.value.trim().toLowerCase();
      if(!q){ this.toast("검색어를 입력하세요", true); return; }
      const matches = this.state.subjects.filter(s=> s.name.toLowerCase().includes(q));
      if(matches.length===0){ this.searchHint.textContent = "검색 결과 없음"; this.toast("검색 결과 없음", true); return; }
      this.searchHint.textContent = `일치: ${matches.map(m=>m.name).join(", ")}`;
      location.hash = "#/subjects/" + matches[0].id;
    },
    renderSidebar(){
      $$("#mainNav a[data-route]").forEach(a=> a.classList.toggle("active", location.hash.startsWith(a.getAttribute("href"))));
      this.subjectQuickList.innerHTML = "";
      if(this.state.subjects.length===0){
        this.subjectQuickList.innerHTML = `<div class="empty">교과가 없습니다</div>`;
      }else{
        this.state.subjects.forEach(s=>{
          const btn = document.createElement("a");
          btn.href = "#/subjects/" + s.id;
          btn.className = "chip" + (this.state.selectedSubjectId===s.id ? " active" : "");
          btn.innerHTML = `<span>${s.name}</span>`;
          this.subjectQuickList.appendChild(btn);
        });
      }
    },
    route(){
      // REMOVED: `this.app.classList.remove("practice-mode");` as it's better to handle it in the view function itself
      const hash = location.hash || "#/dashboard";
      this.renderSidebar();
      const [_, route, id] = hash.split("/");
      switch(route){
        case "dashboard": return this.viewDashboard();
        case "subjects": return id ? this.viewSubject(id) : this.viewSubjects();
        case "practice": return this.viewPractice();
        case "analyze": return this.viewAnalyze();
        case "questions": return this.viewQuestions();
        case "all-questions": return this.viewAllQuestions();
        case "settings": return this.viewSettings();
        default: location.hash = "#/dashboard";
      }
    },

    /* ---------- Views ---------- */
    viewDashboard(){
      this.app.classList.remove("practice-mode");
      this.sidebar.style.display = "";
      $(".topbar").style.display = "";
      const recent = [...this.state.subjects].sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0)).slice(0,5);
      const unanswered = this.state.subjects.reduce((acc,s)=> acc + s.questions.filter(q=>!q.answer).length ,0);
      const totalQ = this.state.subjects.reduce((acc,s)=> acc + s.questions.length ,0);
      this.view.innerHTML = `
        <div class="grid grid-2">
          <div class="card" style="grid-column: 1 / -1;">
            <h2>요약</h2>
            <table class="table">
              <tr><th>교과 수</th><td>${this.state.subjects.length}</td></tr>
              <tr><th>질문 수</th><td>${totalQ}</td></tr>
              <tr><th>미답변 질문</th><td>${unanswered}</td></tr>
            </table>
          </div>
          <div class="card" style="grid-column: 1 / -1;">
            <h2>최근 편집한 교과</h2>
            ${ recent.length ? `<div class="hscroll">${recent.map(s=>`<a class="chip" href="#/subjects/${s.id}">${s.name}</a>`).join("")}</div>` : `<div class="empty">최근 편집 없음</div>` }
          </div>
        </div>
      `;
    },

    viewSubjects(){
      this.app.classList.remove("practice-mode");
      this.sidebar.style.display = "";
      $(".topbar").style.display = "";
      const list = [...this.state.subjects].sort((a,b)=> a.name.localeCompare(b.name,"ko"));
      this.view.innerHTML = `
        <div class="card">
          <h1>교과 목록</h1>
          <div class="row" style="margin-bottom: 12px;">
            <input id="newSubjectInputInView" class="input subject-add-box" placeholder="새 교과명" />
            <button class="button small" id="addSubjectBtnInView">➕ 추가</button>
          </div>
          ${ list.length ? `
            <table class="table">
              <thead><tr><th>교과명</th><th>질문</th><th>최근 수정</th><th></th></tr></thead>
              <tbody>
                ${list.map(s=>`
                  <tr>
                    <td><a href="#/subjects/${s.id}">${s.name}</a></td>
                    <td>${s.questions.length}</td>
                    <td>${fmtTime(s.updatedAt)}</td>
                    <td class="row-nowrap">
                      <button class="button ghost small" data-rename="${s.id}">이름 변경</button>
                      <button class="button danger small" data-del="${s.id}">삭제</button>
                    </td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          ` : `<div class="empty">교과가 없습니다. 교과를 추가해 주세요.</div>`}
        </div>
      `;
      $$("[data-rename]").forEach(btn=> btn.addEventListener("click", ()=> this.renameSubject(btn.dataset.rename)));
      $$("[data-del]").forEach(btn=> btn.addEventListener("click", ()=> this.deleteSubject(btn.dataset.del)));
      
      const newSubjectInputInView = $("#newSubjectInputInView");
      const addSubjectBtnInView = $("#addSubjectBtnInView");
      addSubjectBtnInView.addEventListener("click", () => this.addSubject(newSubjectInputInView.value));
      newSubjectInputInView.addEventListener("keydown", e => {
        if(e.key === "Enter") this.addSubject(newSubjectInputInView.value);
      });
    },

    viewSubject(id){
      this.app.classList.remove("practice-mode");
      this.sidebar.style.display = "";
      $(".topbar").style.display = "";
      const s = this.state.subjects.find(x=>x.id===id);
      if(!s){ this.view.innerHTML = `<div class="empty">해당 교과가 없습니다.</div>`; return; }
      this.state.selectedSubjectId = id; this.save(); this.renderSidebar();
      const unanswered = s.questions.filter(q=>!q.answer).length;
      this.view.innerHTML = `
        <div class="grid grid-2">
          <div class="card">
            <h1>${s.name}</h1>
            <div class="row-nowrap">
              <button class="button ghost small" id="renameBtn">이름 변경</button>
              <button class="button danger small" id="deleteBtn">교과 삭제</button>
              <span class="muted" style="margin-left:auto">미답변 ${unanswered} / 총 ${s.questions.length}</span>
            </div>
            <div class="divider"></div>
            <div class="row" style="justify-content:space-between; align-items:flex-end">
              <div class="muted">생기부</div>
              <div class="muted" id="srbByteCount"></div>
            </div>
            <div id="srbView" class="srb-box" title="더블클릭 편집">${esc(s.srb || "생기부 없음 (더블클릭 또는 편집으로 입력)")}</div>
            <div id="srbEdit" style="display:none">
              <textarea id="srbTextarea" class="field" placeholder="이 교과의 생기부를 붙여넣거나 작성하세요.">${escAttr(s.srb||"")}</textarea>
              <div class="toolbar">
                <button class="button small">저장</button>
                <button class="button ghost small">취소</button>
              </div>
            </div>
            <div class="toolbar">
              <button class="button small" id="editSrbBtn">편집</button>
              <button class="button ghost small" id="clearSrbBtn">지우기</button>
            </div>
          </div>
          <div class="card">
            <h2>질문 리스트</h2>
            <div class="card" style="margin-bottom:12px; border:1px dashed var(--border); background:rgba(17,24,39,.03); padding:12px">
              <div class="row-nowrap">
                <input id="newQ" class="field" placeholder="새로운 질문을 입력하세요">
                <button class="button small" id="addQBtn">➕ 추가</button>
              </div>
            </div>
            ${ s.questions.length ? "" : `<div class="empty">질문이 없습니다.</div>` }
            <div id="qList"></div>
          </div>
        </div>
      `;
      // SRB edit
      const srbView = $("#srbView");
      const srbEdit = $("#srbEdit");
      const srbTextarea = $("#srbTextarea");
      const srbByteCount = $("#srbByteCount");

      function updateSrbDisplay() {
          const text = srbTextarea.value;
          srbView.innerHTML = esc(text || "생기부 없음 (더블클릭 또는 편집으로 입력)");
          srbByteCount.textContent = `바이트: ${calculateSrbBytes(text)}`;
      }

      $("#editSrbBtn").addEventListener("click", ()=>{ 
        srbView.style.display="none"; 
        srbEdit.style.display="block"; 
        srbTextarea.focus(); 
        updateSrbDisplay();
      });
      srbView.addEventListener("dblclick", ()=> $("#editSrbBtn").click());
      const srbBtns = $$("#srbEdit .button");
      srbBtns[0].addEventListener("click", ()=>{
        const t = srbTextarea.value.trim(); s.srb = t; s.updatedAt = now(); this.save(); this.toast("생기부 저장됨"); this.viewSubject(id);
      });
      srbBtns[1].addEventListener("click", ()=>{ srbEdit.style.display="none"; srbView.style.display="block"; });
      $("#clearSrbBtn").addEventListener("click", ()=>{ if(confirm("생기부를 비울까요?")){ s.srb=""; s.updatedAt=now(); this.save(); this.viewSubject(id);} });
      $("#renameBtn").addEventListener("click", ()=> this.renameSubject(id));
      $("#deleteBtn").addEventListener("click", ()=> this.deleteSubject(id));
      srbTextarea.addEventListener('input', updateSrbDisplay);
      updateSrbDisplay();

      // manual questions
      $("#newQ").addEventListener("keydown", e=>{ if(e.key==="Enter") $("#addQBtn").click(); });
      $("#addQBtn").addEventListener("click", ()=>{
        const text = $("#newQ").value.trim(); if(!text){ this.toast("질문을 입력하세요", true); return; }
        s.questions.push({ id:uid(), text, answer:"", hint:"", starred:false, source:"manual", createdAt:now(), updatedAt:now() });
        s.updatedAt = now(); this.save(); this.viewSubject(id); this.toast("질문 추가됨");
      });

      // render questions
      const qList = $("#qList");
      s.questions.forEach(q=>{
        if(typeof q.hint!=="string") q.hint="";
        const node = document.createElement("details");
        node.open = false;
        node.innerHTML = `
          <summary class="row-nowrap">
            <span>${esc(q.text)}</span>
            <span class="tag"></span>
            <span style="margin-left:auto" class="row-nowrap">
              <button class="button ghost small" data-star="${q.id}">${q.starred?"★":"☆"}</button>
              <button class="button ghost small" data-del="${q.id}">삭제</button>
            </span>
          </summary>
          <div class="col" style="margin-top:8px">
            <label>힌트</label>
            <textarea class="field" data-hint="${q.id}" placeholder="키워드/구조/답변 뼈대 등 힌트를 적어두세요.">${escAttr(q.hint||"")}</textarea>
            <label>답변</label>
            <textarea class="field" data-ans="${q.id}" placeholder="여기에 답변을 정리하세요.">${escAttr(q.answer||"")}</textarea>
            <div class="toolbar">
              <button class="button small" data-save="${q.id}">저장</button>
            </div>
          </div>
        `;
        qList.appendChild(node);
      });
      $$("[data-save]").forEach(btn=> btn.addEventListener("click", ()=>{
        const idq = btn.dataset.save;
        const q = s.questions.find(x=>x.id===idq);
        q.hint = $(`[data-hint="${idq}"]`).value.trim();
        q.answer = $(`[data-ans="${idq}"]`).value.trim();
        q.updatedAt = now(); s.updatedAt = now();
        this.save(); this.toast("저장됨");
      }));
      $$("[data-del]").forEach(btn=> btn.addEventListener("click", ()=>{
        const idq = btn.dataset.del;
        if(!confirm("삭제할까요?")) return;
        s.questions = s.questions.filter(x=> x.id!==idq);
        s.updatedAt = now(); this.save(); this.viewSubject(id);
      }));
      $$("[data-star]").forEach(btn=> btn.addEventListener("click", ()=>{
        const idq = btn.dataset.star;
        const q = s.questions.find(x=>x.id===idq);
        q.starred = !q.starred; q.updatedAt = now(); s.updatedAt=now();
        this.save(); btn.textContent = q.starred ? "★" : "☆";
      }));
      this.autoExpandAllTextareas();
    },
    
    viewQuestions(){
        this.app.classList.remove("practice-mode");
        this.sidebar.style.display = "";
        $(".topbar").style.display = "";
        // Get the first subject or null
        let selectedId = this.state.selectedSubjectId || this.state.subjects[0]?.id || null;
        if(selectedId) {
            this.state.selectedSubjectId = selectedId;
            this.save();
        }

        const subjectsHtml = this.state.subjects.map(sub => `<option value="${sub.id}" ${sub.id === selectedId ? 'selected' : ''}>${esc(sub.name)}</option>`).join('');
        

        this.view.innerHTML = `
            <div class="grid grid-2">
                <div class="card">
                    <h1>예상 질문 작성</h1>
                    <div class="divider"></div>
                    <div class="col">
                        <label>교과 선택</label>
                        <select class="field" id="subjectSelector">
                            <option value="">- 교과를 선택해 주세요 -</option>
                            ${subjectsHtml}
                        </select>
                    </div>
                    <div class="col" style="margin-top: 12px;">
                        <div class="row" style="justify-content:space-between; align-items:flex-end">
                            <label>생기부</label>
                            <div class="muted" id="srbByteCount"></div>
                        </div>
                        <textarea id="srbTextarea" class="field" placeholder="선택한 교과의 생기부가 자동으로 불러와집니다."></textarea>
                    </div>
                    <div class="col" style="margin-top: 12px;">
                        <label>키워드</label>
                        <textarea id="keywordsTextarea" class="field" placeholder="핵심 키워드를 입력하세요. (선택사항)"></textarea>
                    </div>
                    <div class="col" style="margin-top: 12px;">
                        <label>예상 질문</label>
                        <textarea id="questionTextarea" class="field" placeholder="질문을 입력하세요."></textarea>
                    </div>
                    <div class="toolbar">
                        
                        <button class="button small" id="addQuestionBtn">➕ 예상 질문 추가</button>
                    </div>
                </div>
                <div class="card">
                    <h2>예상 질문 목록</h2>
                    <div class="divider"></div>
                    <div id="qList">
                        ${!selectedId ? `<div class="empty">좌측에서 교과를 선택하면 질문 목록이 나타납니다.</div>` : ''}
                    </div>
                </div>
            </div>
        `;
        
        const subjectSelector = $("#subjectSelector");
        const srbTextarea = $("#srbTextarea");
        const srbByteCount = $("#srbByteCount");
        const qList = $("#qList");
        const keywordsTextarea = $("#keywordsTextarea");
        const questionTextarea = $("#questionTextarea");
        
        const addQuestionBtn = $("#addQuestionBtn");

        const renderQuestionsList = (subjectId) => {
            qList.innerHTML = '';
            const s = this.state.subjects.find(sub => sub.id === subjectId);
            if (!s || s.questions.length === 0) {
                qList.innerHTML = `<div class="empty">이 교과에는 아직 질문이 없습니다.</div>`;
                return;
            }
            s.questions.forEach(q => {
                const node = document.createElement("details");
                node.open = false;
                node.innerHTML = `
                    <summary class="row-nowrap">
                        <span>${esc(q.text)}</span>
                        <span class="tag"></span>
                        <span style="margin-left:auto" class="row-nowrap">
                            <button class="button ghost small" data-star="${q.id}">${q.starred ? "★" : "☆"}</button>
                            <button class="button ghost small" data-del="${q.id}">삭제</button>
                        </span>
                    </summary>
                    <div class="col" style="margin-top:8px">
                        <label>힌트</label>
                        <textarea class="field" data-hint="${q.id}" placeholder="키워드/구조/답변 뼈대 등 힌트를 적어두세요.">${escAttr(q.hint || "")}</textarea>
                        <label>답변</label>
                        <textarea class="field" data-ans="${q.id}" placeholder="여기에 답변을 정리하세요.">${escAttr(q.answer || "")}</textarea>
                        <div class="toolbar">
                            <button class="button small" data-save="${q.id}">저장</button>
                        </div>
                    </div>
                `;
                qList.appendChild(node);
            });
            $$("[data-save]").forEach(btn => btn.addEventListener("click", this.saveQuestionDetails));
            $$("[data-del]").forEach(btn => btn.addEventListener("click", this.deleteQuestion));
            $$("[data-star]").forEach(btn => btn.addEventListener("click", this.starQuestion));
            this.autoExpandAllTextareas();
        };

        const updateSrbDisplay = () => {
            const text = srbTextarea.value;
            srbByteCount.textContent = `바이트: ${calculateSrbBytes(text)}`;
        };

        const handleSubjectChange = (subjectId) => {
            const selectedSub = this.state.subjects.find(sub => sub.id === subjectId);
            srbTextarea.value = selectedSub?.srb || '';
            this.state.selectedSubjectId = subjectId;
            this.save();
            updateSrbDisplay();
            renderQuestionsList(subjectId);
            questionTextarea.value = '';
            keywordsTextarea.value = '';
            this.autoExpandAllTextareas();
        };

        subjectSelector.addEventListener('change', (e) => handleSubjectChange(e.target.value));
        srbTextarea.addEventListener('input', () => {
            const selectedSub = this.state.subjects.find(sub => sub.id === subjectSelector.value);
            if(selectedSub){
                selectedSub.srb = srbTextarea.value;
                selectedSub.updatedAt = now();
                this.save();
            }
            updateSrbDisplay();
        });

        addQuestionBtn.addEventListener('click', () => {
            const subjectId = subjectSelector.value;
            const questionText = questionTextarea.value.trim();
            const keywordsText = keywordsTextarea.value.trim();

            if (!subjectId) { this.toast("교과를 먼저 선택하세요.", true); return; }
            if (!questionText) { this.toast("예상 질문을 입력하세요.", true); return; }

            const s = this.state.subjects.find(sub => sub.id === subjectId);
            if (s) {
                s.questions.push({
                    id: uid(),
                    text: questionText,
                    answer: "",
                    hint: keywordsText,
                    starred: false,
                    source: "manual",
                    createdAt: now(),
                    updatedAt: now()
                });
                s.updatedAt = now();
                this.save();
                this.toast("질문이 추가되었습니다.");
                renderQuestionsList(subjectId);
                
                questionTextarea.value = '';
                keywordsTextarea.value = '';
                this.autoExpandAllTextareas();
            }
        });
        
        this.saveQuestionDetails = (e) => {
            const idq = e.target.dataset.save;
            const selectedSubject = this.state.subjects.find(s => s.id === subjectSelector.value);
            if (!selectedSubject) return;
            const q = selectedSubject.questions.find(x => x.id === idq);
            if (!q) return;
            q.hint = $(`[data-hint="${idq}"]`).value.trim();
            q.answer = $(`[data-ans="${idq}"]`).value.trim();
            q.updatedAt = now(); selectedSubject.updatedAt = now();
            this.save(); this.toast("저장됨");
        };

        this.deleteQuestion = (e) => {
            const idq = e.target.dataset.del;
            if(!confirm("삭제할까요?")) return;
            const selectedSubject = this.state.subjects.find(s => s.id === subjectSelector.value);
            if (!selectedSubject) return;
            selectedSubject.questions = selectedSubject.questions.filter(x => x.id !== idq);
            selectedSubject.updatedAt = now(); this.save(); renderQuestionsList(selectedSubject.id);
        };

        this.starQuestion = (e) => {
            const idq = e.target.dataset.star;
            const selectedSubject = this.state.subjects.find(s => s.id === subjectSelector.value);
            if (!selectedSubject) return;
            const q = selectedSubject.questions.find(x => x.id === idq);
            if (!q) return;
            q.starred = !q.starred; q.updatedAt = now(); selectedSubject.updatedAt=now();
            this.save(); e.target.textContent = q.starred ? "★" : "☆";
        };

        if (selectedId) {
            handleSubjectChange(selectedId);
        }
    },

    viewAllQuestions(){
        this.app.classList.remove("practice-mode");
        this.sidebar.style.display = "";
        $(".topbar").style.display = "";
        const allQuestions = this.state.subjects.flatMap(s => 
          s.questions.map(q => ({...q, subjectName: s.name}))
        ).sort((a,b) => b.updatedAt - a.updatedAt);

        this.view.innerHTML = `
          <div class="card">
            <h1>전체 질문 목록</h1>
            <div class="muted">총 ${allQuestions.length}개의 질문이 있습니다.</div>
            <div class="divider"></div>
            <div id="qList">
              ${allQuestions.length ? '' : '<div class="empty">질문이 없습니다.</div>'}
            </div>
            <div class="toolbar" style="margin-top: 20px;">
              <a class="button small" href="#/questions">돌아가기</a>
            </div>
          </div>
        `;

        const qList = $("#qList");
        allQuestions.forEach(q => {
            const node = document.createElement("details");
            node.open = false;
            node.innerHTML = `
                <summary class="row-nowrap">
                    <span>${esc(q.text)}</span>
                    <span class="tag" style="margin-left: 12px;">${esc(q.subjectName)}</span>
                    <span style="margin-left:auto" class="row-nowrap">
                        <button class="button ghost small" data-star="${q.id}">${q.starred ? "★" : "☆"}</button>
                    </span>
                </summary>
                <div class="col" style="margin-top:8px">
                    <label>힌트</label>
                    <textarea class="field" data-hint="${q.id}" placeholder="키워드/구조/답변 뼈대 등 힌트를 적어두세요." readonly>${escAttr(q.hint || "")}</textarea>
                    <label>답변</label>
                    <textarea class="field" data-ans="${q.id}" placeholder="여기에 답변을 정리하세요." readonly>${escAttr(q.answer || "")}</textarea>
                </div>
            `;
            qList.appendChild(node);
        });

        // Add star functionality
        $$("[data-star]").forEach(btn => btn.addEventListener("click", (e) => {
            const idq = e.target.dataset.star;
            const q = this.state.subjects.flatMap(s => s.questions).find(x => x.id === idq);
            if (!q) return;
            q.starred = !q.starred;
            this.save();
            e.target.textContent = q.starred ? "★" : "☆";
        }));
        this.autoExpandAllTextareas();
    },

    viewAnalyze(){
      this.app.classList.remove("practice-mode");
      this.sidebar.style.display = "";
      $(".topbar").style.display = "";
      const hash = new URLSearchParams(location.hash.slice(location.hash.indexOf('?')));
      const subId = hash.get('id');
      const s = subId ? this.state.subjects.find(x=>x.id===subId) : null;
      
      this.view.innerHTML = `
        <div class="grid grid-2">
          <div class="card">
            <h1>생기부 분석</h1>
            <div class="divider"></div>
            <div class="col">
              <label>교과 선택</label>
              <select class="field" id="subjectSelector">
                <option value="">- 교과를 선택해 주세요 -</option>
                ${this.state.subjects.map(sub => `<option value="${sub.id}" ${sub.id === subId ? 'selected' : ''}>${esc(sub.name)}</option>`).join('')}
              </select>
            </div>
            <div class="col" style="margin-top:12px">
              <div class="row" style="justify-content:space-between; align-items:flex-end">
                  <label>생기부</label>
                  <div class="muted" id="srbByteCount"></div>
              </div>
              <textarea id="srbTextarea" class="field" placeholder="여기에 생기부 내용을 붙여넣으세요.">${escAttr(s?.srb || '')}</textarea>
            </div>
          </div>
          <div class="card">
            <h2>분석</h2>
            <div class="col">
              <label>흐름 정리</label>
              <textarea id="flowTextarea" class="field" placeholder="면접관에게 전달할 답변의 전체적인 흐름을 정리하세요."></textarea>
            </div>
            <div class="col">
              <label>키워드 정리</label>
              <textarea id="keywordsTextarea" class="field" placeholder="핵심 단어와 개념을 정리하세요."></textarea>
            </div>
            <div class="col">
              <label>핵심 문장 정리</label>
              <textarea id="keySentencesTextarea" class="field" placeholder="가장 중요한 문장을 정리하세요."></textarea>
            </div>
          </div>
        </div>
      `;

      const subjectSelector = $("#subjectSelector");
      const srbTextarea = $("#srbTextarea");
      const srbByteCount = $("#srbByteCount");

      const updateSrbDisplay = () => {
          const text = srbTextarea.value;
          srbByteCount.textContent = `바이트: ${calculateSrbBytes(text)}`;
      };

      subjectSelector.addEventListener('change', (e) => {
        const selectedId = e.target.value;
        const selectedSub = this.state.subjects.find(sub => sub.id === selectedId);
        srbTextarea.value = selectedSub?.srb || '';
        this.state.selectedSubjectId = selectedId;
        this.save();
        updateSrbDisplay();
        this.autoExpandAllTextareas();
      });
      srbTextarea.addEventListener('input', () => {
        const selectedSub = this.state.subjects.find(sub => sub.id === subjectSelector.value);
        if(selectedSub){
            selectedSub.srb = srbTextarea.value;
            selectedSub.updatedAt = now();
            this.save();
        }
        updateSrbDisplay();
      });
      updateSrbDisplay();
      this.autoExpandAllTextareas();
    },

    viewPractice(){
      this.app.classList.remove("practice-mode");
      this.sidebar.style.display = "";
      $(".topbar").style.display = "";
      const subs = this.state.subjects;
      this.view.innerHTML = `
        <div class="grid">
          <div class="card" id="practiceSettings">
            <h1>연습 설정</h1>
            <div class="muted">연습할 교과, 질문 개수, 문항당 제한시간을 선택하세요.</div>
            <div class="divider"></div>
            <div class="grid grid-3" id="subChecks">
              ${ subs.map(s=>`
                <label class="chip"><input type="checkbox" data-sub="${s.id}" checked> ${esc(s.name)} <span class="muted">(${s.questions.length})</span></label>
              `).join("")}
            </div>
            <div class="divider"></div>
            <div class="col">
              <div class="row" style="align-items: center; gap: 8px; flex-wrap: wrap;">
                <label>질문 개수</label>
                <input id="pCount" class="field inline-field" style="max-width:100px" value="10">
                <label>문항당 제한(초)</label>
                <select id="pTimer" class="field inline-field" style="max-width:140px">
                  <option value="0">무제한</option>
                  <option value="30">30초</option>
                  <option value="60" selected>60초</option>
                  <option value="90">90초</option>
                </select>
                <input id="pTimerCustom" class="field inline-field" style="max-width:120px" placeholder="직접 입력(초)">
              </div>
            </div>
            <div class="col" style="margin-top: 16px;">
                <div class="row" style="align-items: center; gap: 8px; flex-wrap: wrap;">
                    <label class="chip"><input type="checkbox" id="pCamera"> 📷 카메라 ON/OFF</label>
                    <label class="chip"><input type="checkbox" id="pRecord"> 🎙️ 녹음 ON/OFF</label>
                </div>
            </div>
            <div class="toolbar" style="margin-top: 16px;">
                <button class="button small" id="startPractice">연습 시작</button>
            </div>
          </div>
          <div class="practice-main" id="practiceArea" style="display: none;"></div>
        </div>
      `;
      $("#startPractice").addEventListener("click", async ()=>{
        const selectedIds = $$("#subChecks input[type=checkbox]:checked").map(cb=>cb.dataset.sub);
        const count = Math.max(1, parseInt($("#pCount").value,10) || 10);
        let limit = parseInt($("#pTimer").value,10) || 0;
        const custom = parseInt(($("#pTimerCustom").value||"").trim(),10);
        if(!isNaN(custom) && custom>=0) limit = custom;
        
        const cameraEnabled = $("#pCamera").checked;
        const recordEnabled = $("#pRecord").checked;
        
        const pool = this.collectQuestions(selectedIds);
        if(pool.length===0){ this.toast("선택 교과에 질문이 없습니다", true); return; }
        
        const qs = shuffle(pool).slice(0, Math.min(count, pool.length));
        this.startPracticeSession(qs, limit, cameraEnabled, recordEnabled);
      });
    },

    async startPracticeSession(qs, perSec, cameraEnabled, recordEnabled) {
      const practiceArea = $("#practiceArea");
      const practiceSettings = $("#practiceSettings");
      
      let stream = null;
      let mediaRecorder = null;
      let audioChunks = [];

      if(cameraEnabled || recordEnabled) {
          try {
              stream = await navigator.mediaDevices.getUserMedia({ video: cameraEnabled, audio: recordEnabled });
              if(recordEnabled) {
                  mediaRecorder = new MediaRecorder(stream);
                  mediaRecorder.ondataavailable = event => {
                      audioChunks.push(event.data);
                  };
                  mediaRecorder.onstop = () => {
                      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                      const audioUrl = URL.createObjectURL(audioBlob);
                      const downloadLink = document.createElement('a');
                      downloadLink.href = audioUrl;
                      downloadLink.download = `practice_recording_${new Date().toISOString()}.webm`;
                      downloadLink.innerHTML = `<button class="button small">다운로드</button>`;
                      
                      const container = $("#download-link-container");
                      if(container) container.appendChild(downloadLink);
                      audioChunks = [];
                  };
                  mediaRecorder.start();
              }
          } catch (err) {
              this.toast("카메라/마이크 접근 권한이 필요합니다.", true);
              console.error("Error accessing media devices.", err);
              return;
          }
      }
      
      practiceSettings.style.display = "none";
      practiceArea.style.display = "flex";

      this.app.classList.add("practice-mode");
      $("#sidebar").style.display = "none";
      $(".topbar").style.display = "none";

      const hasTimer = perSec > 0;
      let idx = 0, done = false;
      let questionStart = null;
      let remaining = perSec;
      let paused = false;
      let pauseStartedAt = 0;
      let accPaused = 0;
      let timerId = null;
      const sessionStart = Date.now();
      const bookmarked = new Set();

      const next = (auto = false) => {
        if (idx < qs.length - 1) {
          idx++;
          resetTimer();
          render();
        } else {
          finish();
        }
      };

      const finish = () => {
        done = true;
        if (timerId) clearInterval(timerId);
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop();
        }
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }

        const elapsedSec = Math.round((Date.now() - sessionStart) / 1000);

        this.app.classList.remove("practice-mode");
        $("#sidebar").style.display = "";
        $(".topbar").style.display = "";

        const stars = qs.filter(q => bookmarked.has(q.id));
        practiceArea.innerHTML = `
          <div class="practice-card">
            <h2>연습 종료</h2>
            <p>총 ${qs.length}문항 · 즐겨찾기 ${stars.length}문항 · 총 소요 ${fmtSec(elapsedSec)}</p>
            ${stars.length ? `<div class="col">${stars.map(q => `<div class="chip" style="margin-bottom:8px">★ ${esc(q.text)}</div>`).join("")}</div>` : `<div class="empty">즐겨찾기 없음</div>`}
            <div id="download-link-container" style="margin-top: 16px;"></div>
            <div class="toolbar">
              <button class="button small" id="restartPractice">다시하기</button>
              <button class="button ghost small" onclick="location.hash='#/dashboard'">홈으로 이동</button>
            </div>
          </div>
        `;
      
      // Bind restart explicitly (hash won't change because we're already on #/practice)
      (function(){
        var rb = document.getElementById('restartPractice');
        if(rb){
          rb.addEventListener('click', ()=>{
            try { 
              // Re-render practice view directly
              app.viewPractice();
              // Also dispatch a synthetic hashchange so guards (ads/anim) sync up
              window.dispatchEvent(new HashChangeEvent('hashchange'));
            } catch(e){
              console.error('restartPractice failed', e);
              location.hash = '#/practice'; // fallback
            }
          });
        }
      })();
    };

      const resetTimer = () => {
        if (hasTimer) {
          remaining = perSec;
          questionStart = Date.now();
          paused = false;
          pauseStartedAt = 0;
          accPaused = 0;
          schedule();
        }
      };

      const schedule = () => {
        if (timerId) clearInterval(timerId);
        if (!hasTimer) return;
        timerId = setInterval(tick, 100);
      };

      const tick = () => {
        if (!hasTimer || paused) return;
        const nowt = Date.now();
        const elapsed = (nowt - questionStart - accPaused) / 1000;
        const left = Math.max(0, perSec - elapsed);
        remaining = left;
        updateTimerUI();
        if (left <= 0) {
          clearInterval(timerId);
          setTimeout(() => next(true), 50);
        }
      };

      const togglePause = () => {
        if (!hasTimer) return;
        if (!paused) {
          paused = true;
          pauseStartedAt = Date.now();
          if(mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.pause();
          updateTimerUI();
        } else {
          paused = false;
          accPaused += (Date.now() - pauseStartedAt);
          if(mediaRecorder && mediaRecorder.state === "paused") mediaRecorder.resume();
          updateTimerUI();
        }
      };

      const restartQuestion = () => {
        if (!hasTimer) return;
        questionStart = Date.now();
        accPaused = 0; paused = false; remaining = perSec;
        schedule(); updateTimerUI();
      };

      const updateTimerUI = () => {
        const timerEl = $("#timerText");
        const bar = $("#timerBarFill");
        const pauseBtn = $("#pauseBtn");
        if (!hasTimer || !timerEl || !bar) return;
        const secs = Math.ceil(remaining);
        timerEl.textContent = fmtSec(secs);
        bar.style.width = `${Math.max(0, Math.min(100, (1 - (remaining / perSec)) * 100))}%`;
        timerEl.classList.toggle("timer-danger", secs <= 5 && !paused);
        if (pauseBtn) pauseBtn.textContent = paused ? "▶ 재개" : "⏸ 일시정지";
        const ses = $("#sessionElapsed");
        if (ses) {
          const e = Math.round((Date.now() - sessionStart) / 1000);
          ses.textContent = fmtSec(e);
        }
      };

      const render = () => {
        const q = qs[idx];
        const sesElapsed = Math.round((Date.now() - sessionStart) / 1000);
        const hintText = (q.hint && q.hint.trim()) ? q.hint : (q.answer || "");
        
        const mediaViewHtml = `
            <div id="media-view" style="flex: 1; max-width: 400px; display: ${cameraEnabled ? 'block' : 'none'};">
                <video id="cameraFeed" autoplay playsinline muted style="width: 100%; border-radius: 12px; border: 1px solid var(--border); transform: scaleX(-1);"></video>
                <div id="recStatus" style="display: ${recordEnabled ? 'block' : 'none'}; color: #fecaca; text-align: center; margin-top: 8px;">🔴 녹음 중</div>
            </div>
        `;
        
        practiceArea.innerHTML = `
          <div class="practice-content-wrapper" style="display: flex; gap: 16px; width: 100%; max-width: 1400px; align-items: flex-start; flex-wrap: wrap-reverse;">
            <div class="practice-card" style="flex: 2; min-width: 400px;">
              <div class="row-nowrap" style="justify-content:space-between; gap:10px; flex-wrap:wrap;">
                <div>문항 ${idx + 1}/${qs.length}${hasTimer ? ` · 남은시간 <span class="timer" id="timerText"></span>` : ""}</div>
                <div class="muted">세션 경과: <span class="timer" id="sessionElapsed">${fmtSec(sesElapsed)}</span></div>
              </div>
               ${hasTimer ? `<div class="bar" style="margin-top:10px"><span id="timerBarFill"></span></div>` : ""}
              <div style="margin-top:20px; min-height: 150px;">
                <h2>${esc(q.text)}</h2>
                <div class="muted">힌트: ${esc((hintText || "").slice(0, 160))}${(hintText && hintText.length > 160) ? "..." : ""}</div>
              </div>
              <div class="toolbar" style="margin-top: 20px;">
                  ${hasTimer ? `<button class="button ghost small" id="pauseBtn">⏸ 일시정지</button>
                  <button class="button ghost small" id="restartBtn">↺ 리셋</button>` : ""}
                  <button class="button ghost small" id="starBtn">${bookmarked.has(q.id) ? "★ 즐겨찾기" : "☆ 즐겨찾기"}</button>
                  <button class="button ghost small" id="finishBtn">연습 종료</button>
                  <button class="button small" id="nextBtn">${idx < qs.length - 1 ? "다음" : "종료"}</button>
              </div>
            </div>
            ${mediaViewHtml}
          </div>
        `;
        
        
        var mv = document.getElementById('media-view'); if(mv){ mv.classList.add('no-anim'); }
if (cameraEnabled && stream) {
            const videoEl = $("#cameraFeed");
            if(videoEl) videoEl.srcObject = stream;
        }

        $("#nextBtn").addEventListener("click", () => next(false));
        $("#finishBtn").addEventListener("click", () => finish());
        $("#starBtn").addEventListener("click", () => {
          if (bookmarked.has(q.id)) bookmarked.delete(q.id);
          else bookmarked.add(q.id);
          render();
        });
        if (hasTimer) {
          $("#pauseBtn").addEventListener("click", togglePause);
          $("#restartBtn").addEventListener("click", restartQuestion);
        }
        updateTimerUI();
      };

      if (hasTimer) {
        resetTimer();
      } else {
        questionStart = Date.now();
      }
      render();
    },

    viewSettings(){
      this.app.classList.remove("practice-mode");
      this.sidebar.style.display = "";
      $(".topbar").style.display = "";
      this.view.innerHTML = `
        <div class="grid grid-2">
          <div class="card">
            <h1>설정</h1>
            <h2>데이터</h2>
            <div class="row-nowrap">
              <button class="button small" id="backupBtn">💾 백업</button>
              <button class="button ghost small" id="restoreBtn">📂 복원</button>
              <input type="file" id="restoreFile" accept="application/json" style="display:none">
            </div>
            <div class="divider"></div>
            <h2>안내</h2>
            <div class="muted">질문 + 힌트 관리, 타이머 포함 연습 모드만 제공합니다.</div>
          </div>
        </div>
      `;
      $("#backupBtn").addEventListener("click", ()=>{
        const blob = new Blob([JSON.stringify(this.state, null, 2)], {type:"application/json"});
        const url = URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="interview_prep_backup.json"; a.click(); URL.revokeObjectURL(url);
        this.toast("백업 완료");
      });
      $("#restoreBtn").addEventListener("click", ()=> $("#restoreFile").click());
      $("#restoreFile").addEventListener("change", async (e)=>{
        const f = e.target.files[0]; if(!f) return;
        try{
          const txt = await f.text(); const data = JSON.parse(txt);
          if(!data || !Array.isArray(data.subjects)) throw new Error("형식 오류");
          if(!confirm("현재 데이터를 백업으로 교체합니다. 진행할까요?")) return;
          this.state = data; this.save(); location.reload();
        }catch(err){ this.toast("복원 실패: "+(err.message||"오류"), true); }
      });
    },

    /* ---------- Practice related functions ---------- */
    collectQuestions(subjectIds){
      const set = new Set(subjectIds);
      const qs = [];
      this.state.subjects.forEach(s=>{ if(set.has(s.id)) qs.push(...s.questions); });
      return qs;
    },
    
    // Auto-resize all relevant textareas
    autoExpandTextarea(el) {
      el.style.height = 'auto';
      el.style.height = el.scrollHeight + 'px';
    },

    autoExpandAllTextareas() {
      const textareas = $$('textarea.field');
      textareas.forEach(el => {
        el.addEventListener('input', () => this.autoExpandTextarea(el));
        this.autoExpandTextarea(el);
      });
    }
  };

  // helpers
  function uid(){ return "id_"+Math.random().toString(36).slice(2)+Date.now().toString(36); }
  function now(){ return Date.now(); }
  function fmtTime(t){ if(!t) return "-"; const d=new Date(t); return d.toLocaleString(); }
  function fmtSec(s){ s = Math.max(0, Math.floor(s)); const m = Math.floor(s/60), r = s%60; return `${String(m).padStart(2,"0")}:${String(r).padStart(2,"0")}`; }
  function esc(s){ return String(s||"").replace(/[&<>"']/g, m=>({"&":"&amp;","<":`&lt;`,">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }
  function escAttr(s){ return esc(s).replace(/"/g,"&quot;"); }
  function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  // Custom byte calculation function
  function calculateSrbBytes(text) {
      let byteCount = 0;
      for (let i = 0; i < text.length; i++) {
          const char = text[i];
          // Check for new line
          if (char === '\n') {
              byteCount += 2;
          }
          // Check for Korean characters (Hangul), including individual jamo
          else if (char.match(/[\uAC00-\uD7A3\u1100-\u11FF\u3131-\u318E]/)) {
              byteCount += 3;
          }
          // All other characters (English, numbers, etc.)
          else {
              byteCount += 1;
          }
      }
      return byteCount;
  }

  app.init();
})();</script>

<!-- Route-based AdSense Guard -->
<script>
(function(){'use strict';
  // Allowed routes for showing auto ads
  const ADS_ALLOWED_HASHES = new Set(['#/dashboard','#/subjects','#/questions','#/all-questions']);
  // Extract client id (from server-injected value or inline string)
  const CLIENT_ID = "ca-pub-3323631723585454";
  let adsScriptLoaded = false;

  function loadAutoAdsOnce() {
    if (adsScriptLoaded) return;
    if (!CLIENT_ID || CLIENT_ID === 'ca-pub-REPLACE_ME') return; // safety
    const s = document.createElement('script');
    s.async = true;
   const CLIENT_ID = 'ca-pub-3323631723585454';
    s.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=' + CLIENT_ID;
    s.crossOrigin = 'anonymous';
    document.head.appendChild(s);
    adsScriptLoaded = true;
  }

  function removeAllAutoAds() {
    // Remove injected <ins class="adsbygoogle">
    document.querySelectorAll('ins.adsbygoogle').forEach(ins => {
      const p = ins.parentElement;
      ins.remove();
      if (p && !p.children.length) p.remove();
    });
  }

  function isAdsAllowedByHash() {
    const route = (location.hash || '').split('?')[0];
    return ADS_ALLOWED_HASHES.has(route);
  }

  function enforceAdsPolicy() {
    if (isAdsAllowedByHash()) loadAutoAdsOnce();
    else removeAllAutoAds();
  }

  window.addEventListener('hashchange', enforceAdsPolicy);
  document.addEventListener('DOMContentLoaded', enforceAdsPolicy);
})();
</script>


<!-- FX: Auto-apply animation classes on route/view changes -->

<!-- FX v3 Runtime -->

<script id="fx-anim-runtime">
(function(){
  const view = document.querySelector('#view') || document.querySelector('.view') || document.body;

  function route(){ return (location.hash||'').split('?')[0]; }
  function isPractice(){ return route() === '#/practice'; }

  function applyTitles(root){
    (root || document).querySelectorAll('.card h1, .card h2').forEach(el => el.classList.add('fx-title'));
  }

  function applyReveal(root){
    const scope = (root || document);
    const sel = '.card, .section, .grid > *, .row, .col, details, summary, .list, .list > *';
    scope.querySelectorAll(sel).forEach((el, idx)=>{
      if (el.closest('.no-anim, .no-ads, #media-view')) return; // skip live/recording areas
      if (el.tagName && (el.tagName.toLowerCase() === 'video' || el.tagName.toLowerCase() === 'canvas')) return;
      if (el.dataset.fxBound) return; // already enhanced
      el.dataset.fxBound = '1';
      el.classList.add('fx-reveal');
      el.style.setProperty('--fx-delay', (idx % 12) * 70 + 'ms');
      if (window.IntersectionObserver) {
        const io = new IntersectionObserver((entries, obs)=>{
          entries.forEach(e=>{
            if(e.isIntersecting){
              e.target.classList.add('is-in');
              obs.unobserve(e.target);
            }
          });
        }, {threshold: 0.08, rootMargin: '0px 0px -8% 0px'});
        io.observe(el);
      } else {
        el.classList.add('is-in');
      }
    });
  }

  function routeFade(){
    if(!view) return;
    if (isPractice()) return; // avoid flicker on live view
    view.classList.remove('fx-view-in');
    requestAnimationFrame(()=> view.classList.add('fx-view-in'));
  }

  function setAnimByRoute(){
    // Disable all animations on practice route
    document.documentElement.classList.toggle('fx-practice-lite', isPractice());
  }

  function enhance(root){
    applyTitles(root);
    applyReveal(root);
  }

  // Initial
  document.addEventListener('DOMContentLoaded', ()=>{
    setAnimByRoute();
    enhance(document);
    routeFade();
  });

  // On hash route change
  window.addEventListener('hashchange', ()=>{
    setAnimByRoute();
    enhance(document);
    routeFade();
  });

  // Observe major DOM changes (but do not trigger view fade to avoid flicker)
  if (window.MutationObserver && view){
    const mo = new MutationObserver((mutations)=>{
      for(const m of mutations){
        if (m.addedNodes && m.addedNodes.length){
          enhance(view);
          break;
        }
      }
    });
    mo.observe(view, { childList: true, subtree: true });
  }
})();
</script>



<!-- Intro logic -->

<script id="intro-logic-safe">
(function(){
  const KEY = 'introSeenV1';
  const intro = document.getElementById('intro-overlay');
  function lsGet(k){ try{ return window.localStorage.getItem(k); }catch(e){ console.warn('localStorage get blocked', e); return null; } }
  function lsSet(k,v){ try{ window.localStorage.setItem(k,v); }catch(e){ console.warn('localStorage set blocked', e); } }
  function showIntro(){
    if(!intro) return;
    intro.style.display = 'block';
    document.documentElement.style.overflow = 'hidden';
  }
  function hideIntro(setSeen){
    if(!intro) return;
    intro.style.display = 'none';
    document.documentElement.style.overflow = '';
    if(setSeen) lsSet(KEY, '1');
  }
  function route(){ return (location.hash||'').split('?')[0]; }
  function maybeShow(){
    if(!intro) return;
    const seen = lsGet(KEY);
    const r = route();
    if(!seen && (r === '' || r === '#/' || r === '#/dashboard')){
      showIntro();
    }
  }
  document.addEventListener('DOMContentLoaded', maybeShow);
  window.addEventListener('hashchange', ()=>{ if(intro && intro.style.display === 'none') maybeShow(); });

  document.addEventListener('click', (e)=>{
    if(e.target && e.target.id === 'enterApp'){ hideIntro(true); if(!location.hash) location.hash = '#/dashboard'; }
    if(e.target && e.target.id === 'skipIntro'){ hideIntro(true); }
  });
})();
</script>



<!-- --- AdSafe patch: dynamic Auto ads loader --- -->
<script>
(function(){
  const ALLOW = new Set([
    '#/dashboard', '#/subjects', '#/questions', '#/all-questions', '#/analyze', '#/settings', '#/'
  ]);
  let adsLoaded = false;
  const ADS_URL = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3323631723585454';

  const route = () => (location.hash || '#/').replace(/\?.*$/, '');

  const setPracticeGuard = () => {
    document.documentElement.classList.toggle('practice-mode', route() === '#/practice');
  };

  const ensureAutoAds = () => {
    const r = route();
    if (adsLoaded || !ALLOW.has(r)) return;
    const s = document.createElement('script');
    s.async = true;
    s.src = ADS_URL;
    s.crossOrigin = 'anonymous';
    document.head.appendChild(s);
    adsLoaded = true;
  };

  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#enterApp, #enter, #enter-hero');
    if (!btn) return;
    setTimeout(() => { setPracticeGuard(); ensureAutoAds(); }, 0);
  });

  document.addEventListener('DOMContentLoaded', () => {
    setPracticeGuard();
    ensureAutoAds();
  });
  window.addEventListener('hashchange', () => {
    setPracticeGuard();
    ensureAutoAds();
  });
})();
</script>
<!-- --- AdSafe patch end --- -->


<!-- AdSense dynamic loader: loads only on content routes (safe) -->
<script>
(function(){
  const ALLOW = new Set([
    '#/dashboard', '#/subjects', '#/questions', '#/all-questions', '#/analyze', '#/settings', '#/'
  ]);
  const ADS_URL = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3323631723585454';
  let __adsLoaded = false;

  const route = () => (location.hash || '#/').replace(/\?.*$/, '');

  function setPracticeGuard(){
    document.documentElement.classList.toggle('practice-mode', route() === '#/practice');
  }

  function ensureAutoAds(){
    if (__adsLoaded) return;
    const r = route();
    if (!ALLOW.has(r)) return;
    // append adsbygoogle.js once
    const s = document.createElement('script');
    s.async = true;
    s.crossOrigin = 'anonymous';
    s.src = ADS_URL;
    s.onload = function(){
      try { (window.adsbygoogle = window.adsbygoogle || []).push({}); } catch(e){}
    };
    document.head.appendChild(s);
    __adsLoaded = true;
  }

  function notifyPageview(){
    try {
      if (window.adsbygoogle && window.adsbygoogle.loaded) {
        (window.adsbygoogle = window.adsbygoogle || []).push({});
      }
    } catch(e){}
  }

  // Bind intro CTA(s)
  document.addEventListener('click', function(e){
    const btn = e.target.closest('#enterApp, #enter, #enter-hero');
    if (!btn) return;
    setTimeout(function(){
      setPracticeGuard();
      ensureAutoAds();
      notifyPageview();
    }, 0);
  });

  // Initial load + route changes
  document.addEventListener('DOMContentLoaded', function(){
    setPracticeGuard();
    ensureAutoAds();
  });
  window.addEventListener('hashchange', function(){
    setPracticeGuard();
    ensureAutoAds();
    notifyPageview();
  });
})();
</script>

</body>
</html>
